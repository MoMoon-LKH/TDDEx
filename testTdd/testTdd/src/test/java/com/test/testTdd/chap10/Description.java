package com.test.testTdd.chap10;

public class Description {

    /*
    테스트 코드와 유지보수

    유지보수를 해야되는 이유
        - 테스트 실패 여부와 상관없이 빌드하고 배포하기 시작한다면
          테스트 코드의 가치를 잃기 시작
            - 테스트 코드는 코드를 변경하였을 때 기존 기능이 올바르게 작동하는지 확인하는 회귀 테스트를 자동화하는 수단으로 사용
            - 회귀 테스트를 검증하는 범위가 준다
            - 소프트웨어의 품질이 낮아질 가능성이 증가

    좋은 유지보수 습관
        1. 변수나 필드를 사용해서 기댓값 표현 X
            - 테스트 코드를 한번에 이해하기 힘듬
            - 명확한 결과를 제시

        2. 두 개 이상을 검증 X
            - 검증하는 내용이 두 개 이상이면 테스트 결과를 확인할 때 집중도가 떨어짐
            - 테스트가 실패 시 정확한 위치는 몰라도 어느 부분에서 실패했는지 명확해짐

        3. 정확하게 일치하는 값으로 모의 객체 설정 X
            - 모의 객체를 사용하는 이유는 특정 값이 통과되는지 확인하는게 아닌 해당 메서드가 정상적으로 작동하는지 확인
            - 모의 객체 메서드 파라미터를 정확한 값으로 설정 x -> Mockito.anyString() 등 불특정 값 설정
            - 즉 모의 객체 메서드 파라미터는 불특정 값 -> 검증할 메서드 파라미터는 특정 값 -> 통과
            - 모의 객체 호출 여부도 마찬가지 특정 값을 사용해서 호출여부를 검증할 경우 전달한 파라미터 값을
              변경할 경우 깨질 위험이 있기 때문에
            - 테스트 코드 수정 시 모의 객체 관련 코드를 함께 수정할 빈도를 줄이기 위함

        4. 과도한 구현 검증 X
            - 내부 구현 검증하는 코드는 테스트 코드 유지보수에 도움 X
            - 구현 구조를 변경하면 테스트가 깨질 위험이 있음
            - 내부 구현은 언제든지 바뀔 수 있기 때문에 테스트 코드는 내부 구현보다 실행 결과에 대해 검증해야됨
                ex) register() 안의 패스워드 강도 메서드가 호출되는 것보단 register() 결과 값이 올바른지 검증

        5. @BeforeEach 통해 중복된 상황을 설정 X (해당 테스트 메서드가 동일한 값을 가진 객체 사용)
            - 후에 해당 테스트 메서드를 확인하려면 @BeforeEach 가 설정된 메서드를 확인해야됨
                -> 이는 편집창을 이동하면서 확인해야됨
            - 테스트가 깨지기 쉬운 구조
                -> 모든 테스트가 동일한 상황 코드를 공유하기 때문에 조금만 변경해도 테스트가 깨짐
                -> 1번과 연관, 기댓값을 변수가 아닌 특정 값으로 표현하기 때문에 @BeforeEach가 변경되면 모두 변경해야됨
            - 테스트 메서드는 하나의 별도 프로그램으로 구성되어야됨 -> 상활 구성 코드가 테스트코드 안에 위치해야됨
                -> 테스트 구분 기준을 class가 아닌 method로 구분

         6. 통합 테스트에서 데이터 공유 주의
            - DB 연동을 포함한 통합 테스트는 DB 데이터를 알맞게 구성해야됨
                - 테스트를 실행할 때마다 DB 데이터를 초기화하는 쿼리 실행
                    -> @Sql를 통해 특정 쿼리를 실행 가능
                - 초기화 파일을 통해 많은 테스트가 깨질 수 있음
            - 초기화 데이터를 나눠서 생각
                - 모든 테스트가 값은 값을 사용하는 데이터 ex) 코드값 데이터
                    - 코드값 데이터는 바뀌지않음
                - 테스트 메서드에서만 필요한 데이터 ex) 중복 ID 검사를 위한 회원 데이터

         7. 통합 테스트의 상황 설정을 위한 보조 클래스 사용
            - 쿼리 실행에 대해 코드가 여러 테스트 코드에 중복
                - 테이블 이름이나 컬럼 이름이 바뀌면 여러 테스트 메서드를 수정해야함 -> 유지보수가 좋지않음
            - 직접 상황을 구성하면서 코드 중복을 없애는 방법 -> 보조 클래스 사용
                -> DB 관련 sql 메서드 클래스 작성
            - select 조회 코드가 여러 테스트 메서드에 중복되어 있으면 유지보수에 좋지 않다
                -> 보조 클래스 사용

         8. 실행 환경이 다르다고 실패 X
            - 같은 테스트 메서드가 실행 환경에 따라 성공하거나 실패하면 안된다
                -> ex) 로컬 개발 환경 성공, 빌드 서버 실행 실패 -> 파일 경로
                    -> 상대 경로
                    -> 시스템에서 제공하는 임시 폴더
            - 특정 OS 환경에서만 실행되야 되는 테스트일 경우
                - @EnabledOnOs, @DisabledOnOs 를 통해 OS에 따른 테스트 실행 여부를 지정

         9. 실행 시점이 다르다고 실패 X
            - 실행 시점을 제어할 수 있는 코드를 작성

         10. 랜덤하게 실패 X
            - 랜덤값이 결과 검증에 영향을 준다면 구조를 변경
                -> 생성자를 통해 값을 받도록 수정

         11. 필요하지 않은 값은 설정 X
            - 검증이 필요하지 않은 값까지 설정
                -> 필요하지 않은 값까지 설정하고 있음

        12. 조건부로 검증 X
            - 테스트 성공하거나 실패해야 된다
            - 검증 코드는 무조건 있어야된다

        13. 통합 테스트는 필요하지 않은 범위까지 연동 X
            - @SpringBootTest는 서비스, 컨트롤러, 등 모든 스프링 빈을 초기화
                -> 초기화하는 시간이 길어짐
            - repository만 테스트 하려면 @JdbcTest -> DB 관련된 설정만 초기화
        
        14. 더이상 쓸모없는 테스트 코드
            - 테스트 커버리지를 높이기 위한 목적으로 작성한 코드
                -> 테스트 커버리지 : 테스트하는 동안 실행하는 코드가 얼마나 되는지 설명하기 위해 사용하는 지표
                    - 메서드의 길이가 10줄 -> 테스트하는 동안 8줄의 코드가 실행 -> 이때 테스트커버리지는 80%


     단위 테스트를 위한 객체 생성 보조 클래스
     - 상황을 구성하기 위해 구성 코드가 복잡하다면 객체 생성 클래스를 따로 생성
        - Factory를 통해 상황에 따른 구성코드 생성 메서드 생성
        - Builder 패턴 제공함으로서 변경 하고싶은 값만 설정 가능
    - 코틀린으로 간단하게 구현 가능
     */

}
