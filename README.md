# 테스트주도개발 정리

### 테스트주도개발 이란
#### TDD (Test-driven Development)
 - 테스트를 먼저 작성하고 실제 코드 구현
 - 즉 테스트가 주도하여 개발하는 방식
#### 장점
- 결함 감소
- 스트레스 감소
- 빠른 피드백
<br>

### TDD 흐름
기능을 검증하는 테스트 작성 -> 코딩 -> 리펙토링 -> 반복 

#### ttd 적용 방법
데이터를 조회해 엑셀 파일로 만들어서 제공
```
기존 과정
1. 디버깅 또는 코드 구현
2. 톰캣 실행, 브라우저 실행
3. 폼 이동, 폼 전송
4. 에러 발생, 과정 1로 이동
5. 다운로드한 엑셀 확인 후 이상 발견, 과정 1로 이동

TDD 적용
1. DB 조회 기능에 대한 테스트 작성 -> 통과할 때까지 구현
2. 엑셀 파일 생성하는 코드에 대한 테스트 작성 -> 통과할 때까지 구현
3. 컨트롤러에서 파일 다운로드 처리 테스트 작성 -> 통과할 때까지 구현
4. 톰캣 구동하고 브라우저 실행해서 테스트 진행
```
<br>

### 작성순서
- 쉬운 경우 -> 어려운 경우 
- 예외적인 경우 -> 정상인 경우
  
해당 경우들을 순차적으로 작성 <br>
즉, 한번에 구현할 코드가 적은 순서로 작성 (구현하기 쉬움)
<br><br>

### 설계
#### 1. 기능
 - 입력
 - 결과

사용자에게 제공하는 기능은 위 두 가지로 나뉘어진다
<br>

#### 2. 이름 설계
- 다른 개발자가 봐도 한눈에 파악되도록 정확하게 이름 설계할 것
- 이 과정은 매우 중요한 부분
<br><br>

### 테스트
#### 테스트 범위 종류
  - 단위 테스트 (서비스, 모델)
  - 통합 테스트 (웹 서버, DB)
  - 기능 테스트 (프런트 포함)

#### 기능 테스트
  - 사용자 입장에서 시스템이 제공하는 기능이 올바르게 동작하느지 확인
  - 모든 구성이 필요 ( ex) 회원가입의 경우 웹브라우저, 웹서버, 데이터베이스)

#### 통합 테스트
  - 시스템의 각 구성 요소가 올바르게 연동되는지 확인
  - 소프트웨어의 코드를 직접 테스트
  - 웹 어플리케이션

#### 단위 테스트
  - 개별 코드나 컴포넌트가 기대한대로 동작하는지 확인
  - 한 테스트나 한 메서드와 같이 작은 범위를 확인

#### 테스트 코드는 단위 테스트와 통합 테스트를 섞어서 작성
  - 통합 테스트보단 단위 테스트를 더 많이 작성
  - 단위 테스트에선 다양한 상황을 다루고 통합 테스트나 기능 테스트는 주요 상황에 대해 작성
<br><br>

### JUnit 5
 #### 1. 구성요소
 ```
 JUnit 플랫폼 : 테스팅 프레임워크를 구동하기 위한 런처와 테스트 엔진을 위한 API 제공
 JUnit 주피터(Jupiter) : JUnit 5를 위한 테스트 API와 실행 엔진을 제공
 JUnit 빈티지(Vintage) : JUnit 3과 4로 작성된 테스트를 JUnit 5 플랫폼에서 실행하기 위한 모듈을 제공
 ```
 
 #### 2. 검사 메서드
 ```
 - assertEquals(expected, actual) : 실제 값(actual)이 기대하는 값(expected)과 같은지 검사
 - assertNotEquals(unexpected, actual) : 실제 값이 특정 값이 같지 않은지 검사
 - assertSame(Object expected, Object actual) : 두 객체가 동일한지 검사
 - assertNotSame(Object unexpected, Object actual) : 두 객체가 동일하지 않은 객체인지 검사
 - assertTrue(boolean condition) : 값이 true 인지 검사
 - assertFalse(boolean condition) : 값이 false 인지 검사
 - assertNull(Object actual) : 값이 null 인지 검사
 - assertNotNull(Object actual) : 값이 null 아닌지 검사
 - fail() : 테스트를 실패 처리
 ```

#### 3. Exception 발생 유무 검사 메서드
```
 - assertThrows(Class<T> expectedType, Executable executable) : executable 을 실행한 결과로 지정한 타입의 익셉션이 발생하는지 검사
 - assertDoesNotThrow(Executable executable) : executable 을 실행한 결과로 익셉션이 발생하지않는지 검사
```

#### 4. Test 실행 순서
- 테스트 메서드를 포함한 객체 생성
- (존재하면) @BeforeEach 애노테이션이 붙은 메서드 실행
- @Test 애노테이션이 붙은 메서드 실행
- (존재하면) @AfterEach 애노테이션이 붙은 메서드 실행
<br>

#### 5. 테스트 애노테이션
@BeforeEach
- 테스트 메서드마다 실행되기 전에 실행되는 메서드
- 테스트를 실행하는데 필요한 사전 작업을 할 때 사용

@AfterEach
- 테스트 메서드마다 실행한 후에 실행되는 메서드
- 테스트를 실행한 후 정리할 작업이 필요할 때 사용

@Disabled
- 특정 테스트 메서드 생략

@DisplayName
- 테스트 표시 이름 설정
<br>

### 대역
> 외부 요소에 대한 대체 요소

#### 대역이 필요한 시점
- 외부요인으로 인해 테스트 하기 어려운 경우 <br>
 ㄴ 테스트 대상에서 파일 사용 <br>
 ㄴ DB로부터 데이터를 조회 및 데이터 추가 <br>
 ㄴ 외부의 HTTP 서버와 통신할 필요가 있을 경우 <br>
 등등
 
#### 종류
 - 스텁(Stub) : 구현을 단순한 것으로 대체 -> 테스트에 맞게 단순히 원하는 동작을 수행 ex) StubCardNumberValidator
 - 가짜(Fake) : 제품에는 적합 X, 실제 동작하는 동작을 구현 -> DB 대신에 메모릴 이용해서 구현 ex) MemoryAutoDebitInfoRepository
 - 스파이(Spy) : 호출된 내역을 기록 -> 기록한 내용을 테스트 결과를 검증할 때 사용, Stub일 경우도 있다
 - 모의(Mock) : 기대한 대로 상호작용하는지 행위를 검증 -> 기대한 대로 동작하지 않으면 익셉션을 발생, Stub이자 Spy
 
 
### 테스트 코드와 유지보수
#### 유지보수를 해야되는 이유
- 테스트 실패 여부와 상관없이 빌드하고 배포하기 시작한다면
  테스트 코드의 가치를 잃기 시작
    - 테스트 코드는 코드를 변경하였을 때 기존 기능이 올바르게 작동하는지 확인하는 회귀 테스트를 자동화하는 수단으로 사용
    - 회귀 테스트를 검증하는 범위가 준다
    - 소프트웨어의 품질이 낮아질 가능성이 증가

#### 좋은 유지보수 습관
```
1. 변수나 필드를 사용해서 기댓값 표현 X
   - 테스트 코드를 한번에 이해하기 힘듬
   - 명확한 결과를 제시

2. 두 개 이상을 검증 X
   - 검증하는 내용이 두 개 이상이면 테스트 결과를 확인할 때 집중도가 떨어짐
   - 테스트가 실패 시 정확한 위치는 몰라도 어느 부분에서 실패했는지 명확해짐

3. 정확하게 일치하는 값으로 모의 객체 설정 X
   - 모의 객체를 사용하는 이유는 특정 값이 통과되는지 확인하는게 아닌 해당 메서드가 정상적으로 작동하는지 확인
   - 모의 객체 메서드 파라미터를 정확한 값으로 설정 x -> Mockito.anyString() 등 불특정 값 설정
   - 즉 모의 객체 메서드 파라미터는 불특정 값 -> 검증할 메서드 파라미터는 특정 값 -> 통과
   - 모의 객체 호출 여부도 마찬가지 특정 값을 사용해서 호출여부를 검증할 경우 전달한 파라미터 값을
     변경할 경우 깨질 위험이 있기 때문에
   - 테스트 코드 수정 시 모의 객체 관련 코드를 함께 수정할 빈도를 줄이기 위함

4. 과도한 구현 검증 X
   - 내부 구현 검증하는 코드는 테스트 코드 유지보수에 도움 X
   - 구현 구조를 변경하면 테스트가 깨질 위험이 있음
   - 내부 구현은 언제든지 바뀔 수 있기 때문에 테스트 코드는 내부 구현보다 실행 결과에 대해 검증해야됨
       ex) register() 안의 패스워드 강도 메서드가 호출되는 것보단 register() 결과 값이 올바른지 검증

5. @BeforeEach 통해 중복된 상황을 설정 X (해당 테스트 메서드가 동일한 값을 가진 객체 사용)
   - 후에 해당 테스트 메서드를 확인하려면 @BeforeEach 가 설정된 메서드를 확인해야됨
       -> 이는 편집창을 이동하면서 확인해야됨
   - 테스트가 깨지기 쉬운 구조
       -> 모든 테스트가 동일한 상황 코드를 공유하기 때문에 조금만 변경해도 테스트가 깨짐
       -> 1번과 연관, 기댓값을 변수가 아닌 특정 값으로 표현하기 때문에 @BeforeEach가 변경되면 모두 변경해야됨
   - 테스트 메서드는 하나의 별도 프로그램으로 구성되어야됨 -> 상활 구성 코드가 테스트코드 안에 위치해야됨
       -> 테스트 구분 기준을 class가 아닌 method로 구분

6. 통합 테스트에서 데이터 공유 주의
   - DB 연동을 포함한 통합 테스트는 DB 데이터를 알맞게 구성해야됨
       - 테스트를 실행할 때마다 DB 데이터를 초기화하는 쿼리 실행
           -> @Sql를 통해 특정 쿼리를 실행 가능
       - 초기화 파일을 통해 많은 테스트가 깨질 수 있음
   - 초기화 데이터를 나눠서 생각
       - 모든 테스트가 값은 값을 사용하는 데이터 ex) 코드값 데이터
           - 코드값 데이터는 바뀌지않음
       - 테스트 메서드에서만 필요한 데이터 ex) 중복 ID 검사를 위한 회원 데이터

7. 통합 테스트의 상황 설정을 위한 보조 클래스 사용
   - 쿼리 실행에 대해 코드가 여러 테스트 코드에 중복
       - 테이블 이름이나 컬럼 이름이 바뀌면 여러 테스트 메서드를 수정해야함 -> 유지보수가 좋지않음
   - 직접 상황을 구성하면서 코드 중복을 없애는 방법 -> 보조 클래스 사용
       -> DB 관련 sql 메서드 클래스 작성
   - select 조회 코드가 여러 테스트 메서드에 중복되어 있으면 유지보수에 좋지 않다
       -> 보조 클래스 사용

8. 실행 환경이 다르다고 실패 X
   - 같은 테스트 메서드가 실행 환경에 따라 성공하거나 실패하면 안된다
       -> ex) 로컬 개발 환경 성공, 빌드 서버 실행 실패 -> 파일 경로
           -> 상대 경로
           -> 시스템에서 제공하는 임시 폴더
   - 특정 OS 환경에서만 실행되야 되는 테스트일 경우
       - @EnabledOnOs, @DisabledOnOs 를 통해 OS에 따른 테스트 실행 여부를 지정

9. 실행 시점이 다르다고 실패 X
   - 실행 시점을 제어할 수 있는 코드를 작성

10. 랜덤하게 실패 X
   - 랜덤값이 결과 검증에 영향을 준다면 구조를 변경
       -> 생성자를 통해 값을 받도록 수정

11. 필요하지 않은 값은 설정 X
   - 검증이 필요하지 않은 값까지 설정
       -> 필요하지 않은 값까지 설정하고 있음

12. 조건부로 검증 X
   - 테스트 성공하거나 실패해야 된다
   - 검증 코드는 무조건 있어야된다

13. 통합 테스트는 필요하지 않은 범위까지 연동 X
   - @SpringBootTest는 서비스, 컨트롤러, 등 모든 스프링 빈을 초기화
       -> 초기화하는 시간이 길어짐
   - repository만 테스트 하려면 @JdbcTest -> DB 관련된 설정만 초기화

14. 더이상 쓸모없는 테스트 코드
   - 테스트 커버리지를 높이기 위한 목적으로 작성한 코드
       -> 테스트 커버리지 : 테스트하는 동안 실행하는 코드가 얼마나 되는지 설명하기 위해 사용하는 지표
           - 메서드의 길이가 10줄 -> 테스트하는 동안 8줄의 코드가 실행 -> 이때 테스트커버리지는 80%
```

#### 단위 테스트를 위한 객체 생성 보조 클래스
- 상황을 구성하기 위해 구성 코드가 복잡하다면 객체 생성 클래스를 따로 생성
   - Factory를 통해 상황에 따른 구성코드 생성 메서드 생성
   - Builder 패턴 제공함으로서 변경 하고싶은 값만 설정 가능
- 코틀린으로 간단하게 구현 가능
